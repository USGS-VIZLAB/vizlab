#' Create fetch.make, etc. from the information in viz.yaml
#'
#' Uses information in the corresponding block of viz.yaml to create the
#' makefiles
#'
#' @param blocks character vector of names of blocks in the viz.yaml for which
#'   to make makefiles
#' @param display logical. [also] print the makefiles to the console?
#'
#' @export
createMakefiles <- function(blocks=c('fetch','process','visualize', 'publish'), display=FALSE) {
  makefiles <- c(
    list(makefile=createTopMakefile()),
    lapply(setNames(blocks, paste0(blocks, '.make')), function(block) {
      createBlockMakefile(block, outfile=paste0('vizlab/make/', block, '.make'))
    })
  )
  if(display) {
    lapply(names(makefiles), function(mfname) {
      cat('--- ', mfname, ' ---\n\n', makefiles[[mfname]], '\n\n', sep='')
    })
  }
  invisible(makefiles)
}

#' Create the top-level makefile, which runs/makes/updates the other makefiles
#'
#' Declares the dependency of the other makefiles on the viz.yaml
#'
#' @param outfile filename where the makefile should be written
#'
#' @export
createTopMakefile <- function(outfile='Makefile') {
  makefile <- paste(
    paste0('# Makefile for overall visualization project\n# Do not edit (autogenerated)'),
    createMakeMacros(),
    createMakeRunmakeRules(),
    createCleanRule(),
    sep='\n\n')
  writeLines(makefile, con=outfile)
  if(!dir.exists('vizlab/make/log/make')) dir.create('vizlab/make/log/make', recursive=TRUE)
  invisible(makefile)
}

#' Create the rules to clean out the make-relevant parts of the project
#'
#' All that's deleted should be re-makeable
#'
#' @keywords internal
createCleanRule <- function() {
  restoreCallFunction <- "file.copy(system.file('scripts/callFunction.R', package='vizlab'), './vizlab/make/callFunction.R')"
  createMakeShellRule(
    target='clean',
    cmd=c(
      'rm -r -f vizlab/make',
      'rm -r -f cache',
      'rm -r -f figures',
      'mkdir -p vizlab/make/log/make',
      sprintf('export R_LIBS_USER=$(RLIBSUSER); ${REXPR} "%s"', restoreCallFunction)
    )
  )
}

#' Create the rules to run/make/update the non-top makefiles
#'
#' Each makefile gets a rule to run it and a rule to create the makefile
#' 
#' @keywords internal
createMakeRunmakeRules <- function() {
  # create a list of info for each makefile in similar format to block info read
  # from viz.yaml
  blocks <- c('fetch','process','visualize','publish')
  content.info <- lapply(setNames(blocks, paste0('top/', blocks)), function(block) {
    list(
      id=block,
      location=paste0('vizlab/make/', block, '.make'),
      depfiles=c('viz.yaml', if(file.exists(findProfileYaml())) findProfileYaml()),
      block='makefile'
    )
  })

  # set the 'all' target to include all content items (i.e., makefiles)
  all <- createMakeEmptyRule(
    target='all',
    depends=paste0("\\\n\t", sapply(content.info, `[[`, 'id')))

  # write the rules for each content item (i.e., a makefile)
  items <- sapply(content.info, function(item.info) {
    createMakeItem(item.info)
  })

  # combine all the targets into a single string
  paste(c(list("# Rules", all), items), collapse='\n\n')
}

#' Create a single makefile from the information in viz.yaml
#'
#' Uses information in the corresponding block of viz.yaml to create the
#' makefiles
#'
#' @param block character name of the block in the viz.yaml for which to create a
#'   makefile
#' @param outfile filename where the makefile should be written
#'
#' @export
createBlockMakefile <- function(block=c('fetch','process','visualize','publish'), outfile) {
  block <- match.arg(block)
  makefile <- paste(
    paste0('# Makefile for ', block, ' phase of analysis\n# Do not edit (autogenerated from viz.yaml)'),
    createMakeMacros(),
    createMakeBlockRules(block),
    sep='\n\n')
  createMakeDirs(makefile)
  writeLines(makefile, con=outfile)
  invisible(makefile)
}

#' Create the macros section
#'
#' Create a character string defining the macros to include in every makefile
#' 
#' @export
createMakeMacros <- function() {
  # read user settings from profile.yaml
  profile <- getProfileInfo()
  userlib <- profile$R_LIBS_USER

  # write the macros
  macros <- c(
    if(!is.null(profile$SHELL)) paste0('SHELL="', profile$SHELL, '"'),
    paste0('RLIBSUSER=', if(!is.null(profile$R_LIBS_USER)) paste0('"', profile$R_LIBS_USER, '"') else '$(R_LIBS_USER)'),
    paste0('RARGS=--quiet --no-save --no-restore'), # R_LIBS_USER="',profile$R_LIBS_USER,'"
    paste0('RBATCH="', profile$R, '" CMD BATCH --no-timing $(RARGS)'),
    paste0('REXPR="', profile$R, '" $(RARGS) -e'),
    paste0('RSCRIPT="', profile$RSCRIPT, '" $(RARGS)'))

  # combine into a single string
  paste0('# Macros\n\n', paste(macros, collapse='\n'))
}

#' Create directories mentioned in the makefile
#'
#' Seeks specific directories that are expected to appear in some or all
#' visualization projects. Creates those for which the makefile indicates a need
#'
#' @param makefile character string containing the makefile
createMakeDirs <- function(makefile) {
  # the vizlab/make directory needs to exist so we can put makefiles and other
  # internal documentation there
  if(!dir.exists('vizlab/make')) dir.create('vizlab/make', recursive=TRUE)

  # make log directories if specified
  logdirs <- unique(dirname(grep('^vizlab/make/log', strsplit(makefile, '[[:space:]]')[[1]], value=TRUE)))
  if(length(logdirs) > 0) sapply(logdirs, function(logdir) {
    if(!dir.exists(logdir)) dir.create(logdir, recursive=TRUE)
  })

  # make cache directories if specified
  cachedirs <- unique(dirname(grep('^cache/', strsplit(makefile, '[[:space:]]')[[1]], value=TRUE)))
  if(length(cachedirs) > 0) sapply(cachedirs, function(cachedir) {
    if(!dir.exists(cachedir)) dir.create(cachedir, recursive=TRUE)
  })

  # make figures directories if specified
  figdirs <- unique(dirname(grep('^figures/', strsplit(makefile, '[[:space:]]')[[1]], value=TRUE)))
  if(length(figdirs) > 0) sapply(figdirs, function(figdir) {
    if(!dir.exists(figdir)) dir.create(figdir, recursive=TRUE)
  })

  # create the timestamp file directory if specified
  timestampdir <- unique(dirname(grep('^vizlab/make/timestamps', strsplit(makefile, '[[:space:]|\\|=|:]')[[1]], value=TRUE)))
  if(length(timestampdir) > 0) {
    if(!dir.exists(timestampdir)) dir.create(timestampdir)
  }

  # always copy callFunction.R into the vizlab/make directory, on the assumption
  # that even if there aren't currently any references to it in the makefiles,
  # there will be soon. this script allows us to call a single function via R
  # CMD BATCH
  file.copy(system.file('scripts/callFunction.R', package='vizlab'),
            './vizlab/make/callFunction.R', overwrite=TRUE)
}

#' Create the make rules for a block of the viz.yaml
#'
#' Create the 'all' and specific targets for a makefile for a block of the
#' viz.yaml
#'
#' @param block character name of the block for which to create the make rules
#'
#' @export
createMakeBlockRules <- function(block=c('fetch','process','visualize','publish')) {
  block <- match.arg(block)

  # read information about this block from viz.yaml
  content.info <- getContentInfos(block=block)

  # check for and warn about dependencies on directories
  dir.deps <- unlist(lapply(content.info, function(cinfo) {
    is.dir <- sapply(cinfo$scripts, dir.exists)
    names(is.dir)[is.dir]
  }))
  if(length(dir.deps) > 0) {
    dir.deps.info <- sapply(unique(dir.deps), function(dependency) {
      dependers <- names(dir.deps)[dir.deps == dependency]
      sprintf("* Items depending on the %s directory: %s", dependency, paste(dependers, collapse=', '))
    }, USE.NAMES=FALSE)
    dir.deps.msg <- c(
      '-----WARNING-----',
      paste("Script dependencies should be specific files to avoid Making items too seldom or too often.",
            "You can override the default (a directory) by setting 'scripts' in each viz.yaml item."),
      paste0(dir.deps.info, collapse='\n'), 
      '-----------------')
  } else {
    dir.deps.msg <- NULL
  }
  
  # set the 'all' target to include all content items
  all <- createMakeEmptyRule(
    target='all',
    depends=paste0("\\\n\t", c(sapply(content.info, `[[`, 'id'), 'MakeMessages')))

  # write the rules for each content item
  items <- sapply(content.info, function(item.info) {
    createMakeItem(item.info)
  })
  
  # write any messages the user should see on calling 'make' - so far this is
  # just the directory dependencies issues if present
  if(length(dir.deps.msg) == 0) dir.deps.msg <- paste0(block, ".make looks OK!")
  messages <- createMakeShellRule('MakeMessages', c(), paste0('@echo "', c('', dir.deps.msg, ''), '"'))

  # combine all the targets into a single string
  paste(c(list("# Rules", all), items, list(messages)), collapse='\n\n')
}

#' Make a collection of makefile rules appropriate to a data/figure item
#'
#' @param item.info viz.yaml item info as from \code{getContentInfo}
#' @param ... other args passed to makeMakeItem methods
#'
#' @export
createMakeItem <- function(item.info, ...) UseMethod("createMakeItem")

#' @rdname createMakeItem
#' @export
createMakeItem.default <- function(item.info, ...) {
  if(class(item.info) != 'list')
    stop('could not find createMakeItem method for item type =', class(item.info))

  class(item.info) <- item.info$block
  createMakeItem(item.info, ...)
}

#' \code{createMakeItem.fetch}: create makefile rules for an item in the fetch block
#' of viz.yaml
#'
#' @rdname createMakeItem
#' @importFrom utils methods
#' @export
createMakeItem.fetch <- function(item.info, ...) {

  rules <- list()

  # timestamp rules
  needs.timestamp <- item.info$refetch
  if(needs.timestamp) {
    squote <- function(x) paste0("'", x, "'")
    timestamp.id <- paste0(item.info$id, '_timestamp')
    timestamp.file <- paste0('vizlab/make/timestamps/', item.info$id)
    rules$file.timestamp <- createMakeEmptyRule(
      target=timestamp.file,
      depends=timestamp.id)
    rules$phony.timestamp <- createMakeBatchRule(
      target=timestamp.id,
      fun='fetchTimestamp',
      funargs=c(viz=squote(item.info$id)),
      scripts=item.info$scripts,
      logfile=paste0('fetch/', timestamp.id, '.Rout'))
  }

  # data rules
  item.info$depfiles <- if(needs.timestamp) timestamp.file else c()
  rules <- c(createMakeRulePair(item.info, block='fetch', concat=FALSE), rules)

  # return
  paste(unlist(unname(rules)), collapse='\n')
}

#' \code{createMakeItem.process}: create makefile rules for an item in the
#' process block of viz.yaml
#'
#' @rdname createMakeItem
#' @export
createMakeItem.process <- function(item.info, ...) {
  createMakeRulePair(item.info, block='process', concat=TRUE)
}

#' \code{createMakeItem.visualize}: create makefile rules for an item in the
#' visualize block of viz.yaml
#'
#' @rdname createMakeItem
#' @export
createMakeItem.visualize <- function(item.info, ...) {
  createMakeRulePair(item.info, block='visualize', concat=TRUE)
}

#' \code{createMakeItem.publish}: create makefile rules for an item in the
#' publish block of viz.yaml
#'
#' @rdname createMakeItem
#' @export
createMakeItem.publish <- function(item.info, ...) {
  createMakeRulePair(item.info, block='publish', concat=TRUE)
}

#' \code{createMakeItem.visualize}: create makefile rules for an item in the
#' visualize block of viz.yaml
#'
#' @rdname createMakeItem
#' @export
createMakeItem.makefile <- function(item.info, ...) {
  squote <- function(x) paste0("'", x, "'")
  rules <- list()
  rules$call.make <- createMakeShellRule(
    target=item.info$id,
    depends=item.info$location,
    cmd=paste0('make -f ', item.info$location))
  rules$file.make <- createMakeBatchRule(
    target=item.info$location,
    depends=item.info$depfiles,
    fun='createBlockMakefile',
    funargs=c(block=squote(item.info$id), outfile=squote(item.info$location)),
    logfile=paste0('make', '/', item.info$id, '.Rout'))

  paste(unlist(unname(rules)), collapse='\n')
}

#### General makefile-writing functions ####

#' Make the common rule pair relating IDs to files to commands
#'
#' Make the common rule pair where the item ID is a symbolic target that depends
#' on the file, and the file depends on the scripts, args, dependencies, etc.
#' listed in item.info
#'
#' @param item.info viz.yaml item info as from \code{getContentInfo}
#' @param block length 1 character designating the block for which to make the
#'   rule pair
#' @param concat logical. Should the rules be concatenated into a single string
#'   (TRUE) or left as a list of two rules (FALSE)?
#'
#' @export
createMakeRulePair <- function(item.info, block, concat=TRUE) {

  # arg prep
  squote <- function(x) paste0("'", x, "'")
  dquote <- function(x) paste0('"', x, '"')
  data.file <- item.info$location
  if(!is.null(data.file) && grepl(" ", data.file)) data.file <- dquote(data.file)
  dep.files <- c(
    item.info$depfiles, # depfiles get listed as dependencies but not read in or passed to the function
    sapply(item.info$depends, function(dep) getContentInfo(dep)$location, USE.NAMES=FALSE)
  )
  #dep.args <- sapply(item.info$depends, function(dep) paste0("readData('", dep, "')" ))

  # data args
  rules <- list()
  rules$phony.data <- createMakeEmptyRule(
    target=item.info$id,
    depends=data.file)
  rules$file.data <- createMakeBatchRule(
    target=data.file,
    depends=dep.files,
    fun=block,
    funargs=c(viz=squote(item.info$id)),
    scripts=item.info$scripts,
    logfile=paste0(block, '/', item.info$id, '.Rout'))

  # return
  if(concat) {
    paste(unlist(unname(rules)), collapse='\n')
  } else {
    rules
  }
}


#' Create text for a make rule that has no commands
#'
#' The resulting rule will have only a target and maybe dependencies, no
#' commands
#'
#' @param target character: the target name
#' @param depends character vector: the dependencies
#' @keywords internal
createMakeEmptyRule <- function(target, depends=c()) {
  depends_chr <- paste(depends, collapse=' ')
  sprintf('%s: %s', target, depends_chr)
}

#' Create text for a make rule using RBATCH
#'
#' Create the text for a gnu make target that runs a function using R CMD BATCH
#' and callFunction.R
#'
#' @param target character: the target name
#' @param depends character vector: the dependencies (omit callFunction.R and
#'   scripts; these will be automatically added)
#' @param fun character: the function name, to be ultimately evaluated in an
#'   environment where the scripts have been sourced and library(vizlab) has
#'   been called. if fun is missing, the command section of the make target
#'   declaration will be omitted
#' @param scripts  character vector: the scripts or script directories to load.
#'   omit 'scripts' because this will be automatically preprended
#' @param logfile character: the filename where the R CMD BATCH logfile should
#'   be saved. omit 'vizlab/make/log' because this will be automatically
#'   prepended
#' @keywords internal
createMakeBatchRule <- function(target, depends=c(), fun, funargs=c(), scripts=c(), logfile) {
  # R CMD BATCH works fine, but note for future dev: Rscript and littlr can do
  # everything R CMD BATCH can do and are preferred by Dirk Eddelbuettel. See
  # http://stackoverflow.com/questions/21969145/why-or-when-is-rscript-or-littler-better-than-r-cmd-batch/22358976#22358976,
  # http://stackoverflow.com/questions/14008139/capturing-rscript-errors-in-an-output-file,
  # etc. "To put the output and error in the same file (assuming sh/bash):
  # RScript --no-save --no-restore --verbose myRfile.R > outputFile.Rout 2>&1"

  # modify the arguments to fill in some details
  scripts <- if(length(scripts) > 0) scripts else c()
  depends <- c(depends, scripts)

  # convert complex arguments into character strings
  mQuote <- function(x) if(grepl(' ', x)) sprintf('\\\"%s\\\"', x) else x
  scripts_chr <- if(length(scripts) > 0) {
    paste0(' scripts=', mQuote(paste0("c(", paste0("'", scripts, "'", collapse=','), ")")))
  } else ''
  funargs_chr <- if(length(funargs) > 0) {
    paste0(' funargs=', mQuote(paste0("list(", paste0(names(funargs), "=", funargs, collapse=","), ")")))
  } else ''

  # produce the final character string
  paste(c(
    createMakeEmptyRule(target, depends),
    sprintf('\texport R_LIBS_USER=$(RLIBSUSER);\\'),
    sprintf('\t${RBATCH} "--args fun=%s%s%s" \\', fun, funargs_chr, scripts_chr),
    sprintf('\tvizlab/make/callFunction.R vizlab/make/log/%s', logfile)),
    collapse='\n')
}

#' Create text for a make rule that calls an R expression
#'
#' The R expression will be called by R.exe -e
#'
#' @inheritParams createMakeEmptyRule
#' @param expr character vector of one or more R commands
#' @keywords internal
createMakeExprRule <- function(target, depends=c(), expr) {
  # produce the final character string
  paste(c(
    createMakeEmptyRule(target, depends),
    sprintf('\texport R_LIBS_USER=$(RLIBSUSER);\\'),
    sprintf('\t${REXPR} "%s"', paste0(expr, collapse='; \\\n\t'))),
    collapse='\n')
}

#' Create text for a make rule that calls a shell command
#'
#' The shell command will be called exactly as-is
#'
#' @inheritParams createMakeEmptyRule
#' @param cmd character vector of one or more shell commands
#' @keywords internal
createMakeShellRule <- function(target, depends=c(), cmd) {
  # produce the final character string
  paste(c(
    createMakeEmptyRule(target, depends),
    paste0('\t', cmd)),
    collapse='\n')
}
